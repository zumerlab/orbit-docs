(()=>{var H=class extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML=`
      <style>
        :host {
        --o-fill: var(--o-gray-light);
        --o-stroke: var(--o-fill);
        --o-stroke-width: 1;
        --o-back-fill: transparent;
        --o-back-stroke: none;
        --o-back-stroke-width: 1;
      }
      :host(:hover){
        --o-fill: var(--o-gray-light);
        --o-stroke: var(--o-fill);
        --o-stroke-width: 1;
        --o-back-fill: transparent;
        --o-back-stroke: none;
        --o-back-stroke-width: 1;
      }
      svg {
          width: 100%;
          height: 100%;
          overflow: visible;
          pointer-events: none;
        }
        svg * {
          pointer-events: visiblePainted;
        }
        .progress-bar {
          fill: var(--o-fill);
          stroke: var(--o-stroke);
          stroke-width: var(--o-stroke-width);
          transition: fill 0.25s, stroke 0.25s;
          stroke-linejoin: round;
        }
        .progress-bg {
          fill: var(--o-back-fill);
          stroke: var(--o-back-stroke);
          stroke-width: var(--o-back-stroke-width);
        }
      </style>
      <svg viewBox="0 0 100 100">
        <path class="progress-bg" shape-rendering="geometricPrecision" vector-effect="non-scaling-stroke"></path>
        <path class="progress-bar" shape-rendering="geometricPrecision" vector-effect="non-scaling-stroke"></path>
      </svg>
    `}connectedCallback(){this.update(),this.observer=new MutationObserver(r=>{this.observer.disconnect(),r.forEach(n=>{this.update()}),this.observer.observe(this,{attributes:!0,childList:!0})}),this.observer.observe(this,{attributes:!0,childList:!0})}update(){let r=this.shadowRoot.querySelector(".progress-bg"),n=this.shadowRoot.querySelector(".progress-bar");this.updateArc(r,!0),this.updateArc(n,!1)}updateArc(r,n){let{d:h}=this.calculateArcParameters(n);r.setAttribute("d",h)}getAttributes(){let r=parseFloat(getComputedStyle(this).getPropertyValue("r")||0),n=parseFloat(getComputedStyle(this).getPropertyValue("--o-orbit-number")),h=parseFloat(getComputedStyle(this).getPropertyValue("--o-size-ratio")),o=parseFloat(getComputedStyle(this).getPropertyValue("--o-range")||360),e=parseFloat(getComputedStyle(this).getPropertyValue("--o-progress")||this.getAttribute("value")||0),s=this.getAttribute("shape")||"none",d=parseFloat(getComputedStyle(this).getPropertyValue("--o-stroke-width")),c=(r/n*h-d+.3)/2*100/r/2,l=o,t=parseFloat(this.getAttribute("max"))||100,b;this.classList.contains("outer-orbit")?b=c:this.classList.contains("quarter-outer-orbit")?b=c*-.5:this.classList.contains("inner-orbit")?b=c*-1:this.classList.contains("quarter-inner-orbit")?b=c*.5:b=0;let A=50+b;return{orbitRadius:r,progress:e,strokeWidth:d,realRadius:A,maxAngle:l,maxValue:t,shape:s,arcHeightPercentage:c,orbitNumber:n}}getProgressAngle(r){let{maxAngle:n,progress:h,maxValue:o}=this.getAttributes();return r?(o-1e-5)/o*n:h/o*n}calculateArcParameters(r){let n=this.getProgressAngle(r),{realRadius:h,arcHeightPercentage:o,orbitNumber:e,shape:s,strokeWidth:d}=this.getAttributes(),g=h,c,l,t,b,A,C,a,i,v,O,E,M,k,F,u=Math.PI/2,w=d,R=n*Math.PI/180,y=g+o,f=g-o!==0?g-o:g,p=w*2/e/2/y,$=w*2/e/2/f,P=p-u,x=R-p-u,S=$-u,L=R-$-u;c=50+y*Math.cos(P),l=50+y*Math.sin(P),t=50+y*Math.cos(x),b=50+y*Math.sin(x),E=50+y*Math.cos(x+3*Math.PI/180),k=50+y*Math.sin(x+3*Math.PI/180),C=50+f*Math.cos(S),a=50+f*Math.sin(S),i=50+f*Math.cos(L),v=50+f*Math.sin(L),M=50+f*Math.cos(L+3*Math.PI/180),F=50+f*Math.sin(L+3*Math.PI/180),A=n<=180?0:1;let m=`M ${c},${l} A ${y},${y} 0 ${A} 1 ${t},${b}`;return s==="arrow"&&(m+=`L ${(E+M)/2}  ${(k+F)/2} `),(s==="circle"||s==="bullet")&&(m+=`A ${o}, ${o} 0 0 1 ${i},${v} `),m+=`L ${i} ${v}`,m+=`A ${f},${f} 0 ${A} 0 ${C},${a}`,s==="circle"&&(m+=`A ${o}, ${o} 0 0 1 ${c},${l} `),s==="bullet"&&(m+=`A ${o}, ${o} 0 0 0 ${c},${l} `),s==="arrow"&&(m+=`L ${C+3} ${(l+a)/2}  `),m+="Z",{d:m}}};var T=document.createElement("template");T.innerHTML=`
   <style>
      :host {
        --o-fill: var(--o-gray-light);
        --o-stroke: var(--o-fill);
        --o-stroke-width: 1;
        --o-color: currentcolor;
      }
      :host(:hover){
        --o-fill: var(--o-gray-light);
        --o-stroke: var(--o-fill);
        --o-stroke-width: 1;
        --o-color: currentcolor;
      }
      svg {
        width: 100%;
        height: 100%;
        overflow: visible;
        pointer-events: none;
      }
      svg * {
        pointer-events: visiblePainted;
      }
      #orbitShape {
        fill: var(--o-fill);
        stroke: var(--o-stroke);
        stroke-width: var(--o-stroke-width);
        transition: fill 0.25s, stroke 0.25s;
       
      }
      text {
       fill: var(--o-color);
      }
      #orbitPath {
        fill: transparent;
        stroke: none;
        stroke-width: 0;
      }
   </style>
   <svg viewBox="0 0 100 100">
     <path id="orbitShape" shape-rendering="geometricPrecision" vector-effect="non-scaling-stroke"></path>
     <path id="orbitPath"  shape-rendering="geometricPrecision" vector-effect="non-scaling-stroke" ></path>
     <text>
        <textPath href="#orbitPath"  alignment-baseline="middle"></textPath>
      </text>
   </svg>
 `;var q=class extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.appendChild(T.content.cloneNode(!0))}connectedCallback(){this.update(),this.observer=new MutationObserver(r=>{this.observer.disconnect(),r.forEach(n=>{this.update()}),this.observer.observe(this,{attributes:!0,childList:!0})}),this.observer.observe(this,{attributes:!0,childList:!0}),this.textObserver=new MutationObserver(()=>{let r=this.shadowRoot.querySelector("textPath");r.textContent=this.textContent}),this.textObserver.observe(this,{characterData:!0,subtree:!0})}disconnectedCallback(){this.observer.disconnect(),this.textObserver.disconnect()}update(){let{length:r,fontSize:n,textAnchor:h,fitRange:o}=this.getAttributes(),e=this.shadowRoot.getElementById("orbitPath"),s=this.shadowRoot.getElementById("orbitShape"),d=this.shadowRoot.querySelector("text"),g=this.shadowRoot.querySelector("textPath"),{dShape:c}=this.calculateArcParameters(),{dPath:l}=this.calculateTextArcParameters();s.setAttribute("d",c),e.setAttribute("d",l),h==="start"?(g.setAttribute("startOffset","0%"),g.setAttribute("text-anchor","start")):h==="middle"?(g.setAttribute("startOffset","50%"),g.setAttribute("text-anchor","middle")):h==="end"&&(g.setAttribute("startOffset","100%"),g.setAttribute("text-anchor","end")),o&&g.parentElement.setAttribute("textLength",e.getTotalLength()),d.style.fontSize=`calc(${n} * (100 / (${r}) * (12 /  var(--o-orbit-number) ))`,g.textContent=this.textContent}getAttributes(){let r,n,h,o,e,s=parseFloat(getComputedStyle(this).getPropertyValue("--o-stroke-width")),d=parseFloat(getComputedStyle(this).getPropertyValue("r")||0),g=this.getAttribute("shape")||"none",c=this.hasAttribute("flip")||this.classList.contains("flip"),l=this.hasAttribute("fit-range")||this.classList.contains("fit-range")||!1,t=parseFloat(getComputedStyle(this).getPropertyValue("--o-force")),b=this.getAttribute("text-anchor")||"middle",A=getComputedStyle(this).getPropertyValue("font-size")||getComputedStyle(this).getPropertyValue("--font-size"),C=parseFloat(getComputedStyle(this).getPropertyValue("--o-range")||360),a=parseFloat(this.getAttribute("value"));if(a){n=this.getProgressAngle(C,a);let M=this.previousElementSibling,k=M?parseFloat(getComputedStyle(M).getPropertyValue("--o_stack")):0;this.style.setProperty("--o_stack",k+n),k>=0&&c&&this.style.setProperty("--o-angle-composite",parseFloat(k)+"deg"),k>0&&!c&&this.style.setProperty("--o-angle-composite",parseFloat(k)+"deg")}else r=getComputedStyle(this).getPropertyValue("--o-angle"),n=B(r);h=parseFloat(getComputedStyle(this).getPropertyValue("--o-orbit-number")),o=parseFloat(getComputedStyle(this).getPropertyValue("--o-size-ratio"));let i=d/h*o-s+.3,v=i/2*100/d/2,O=parseFloat(getComputedStyle(this).getPropertyValue("--o-gap"));this.classList.contains("outer-orbit")?e=v:this.classList.contains("quarter-outer-orbit")?e=v*-.5:this.classList.contains("inner-orbit")?e=v*-1:this.classList.contains("quarter-inner-orbit")?e=v*.5:e=0;let E=50+e;return{orbitRadius:d,arcHeight:i,realRadius:E,gap:O,arcAngle:n,shape:g,length:t,fontSize:A,flip:c,fitRange:l,textAnchor:b,arcHeightPercentage:v,innerOuter:e,orbitNumber:h,size:o,strokeWidth:s}}getProgressAngle(r,n){let h=n,o=parseFloat(this.getAttribute("max"))||100;return h/o*r}getControlPoint(r,n,h,o,e="clockwise"){let s=(r+h)/2,d=(n+o)/2,g=h-r,c=o-n,l,t;return e==="clockwise"?(l=s+c*.4,t=d-g*.4):(l=s-c*.4,t=d+g*.4),{xc:l,yc:t}}calculateArcParameters(){let{arcAngle:r,realRadius:n,gap:h,arcHeightPercentage:o,orbitNumber:e,shape:s,strokeWidth:d,arcHeight:g}=this.getAttributes(),c=n,l,t,b=Math.PI/2,A=d,C=r*Math.PI/180,a=c+o,i=c-o!==0?c-o:c,v=(h+A*1.25)/e/a,O=(h+A*1.25)/e/i,E=v-b,M=C-v-b,k=O-b,F=C-O-b;function u(p,$,P=0,x=0){let S=p+P,L=$+x*Math.PI/180;return{x:50+S*Math.cos(L),y:50+S*Math.sin(L)}}let w=u(a,E),R=u(a,M),y=u(i,k),f=u(i,F);if(l=r<=180?0:1,s==="rounded"){let p=g<10?5:g<5?2.5:10,$=u(a,E,0,p/e),P=u(a,M,0,-p/e),x=u(i,k,0,p/e),S=u(i,F,0,-p/e),L=u(a,E,-(p/2)/e,0),m=u(a,M,-(p/2)/e,0),V=u(i,k,p/2/e,0),z=u(i,F,p/2/e,0),X=this.getControlPoint(P.x,P.y,m.x,m.y),Y=this.getControlPoint(z.x,z.y,S.x,S.y),Q=this.getControlPoint(x.x,x.y,V.x,V.y),Z=this.getControlPoint(L.x,L.y,$.x,$.y);t=`M ${$.x},${$.y} A ${a},${a} 0 ${l} 1 ${P.x},${P.y}`,t+=`Q ${X.xc}, ${X.yc} ${m.x}  ${m.y} `,t+=`L ${m.x} ${m.y}`,t+=`L ${z.x} ${z.y}`,t+=`Q ${Y.xc}, ${Y.yc} ${S.x} ${S.y} `,t+=`A ${i},${i} 0 ${l} 0 ${x.x},${x.y}`,t+=`Q ${Q.xc}, ${Q.yc} ${V.x}  ${V.y} `,t+=`L ${V.x} ${V.y}`,t+=`L ${L.x} ${L.y}`,t+=` Q ${Z.xc}, ${Z.yc} ${$.x} ${$.y} `,t+=" Z"}else if(s==="circle"||s==="bullet")t=`M ${w.x},${w.y} A ${a},${a} 0 ${l} 1 ${R.x},${R.y}`,t+=` A 1,1 0 0 1 ${f.x},${f.y} `,t+=` A ${i},${i} 0 ${l} 0 ${y.x},${y.y}`,t+=` A 1,1 0 0 ${s==="circle"?1:0} ${w.x},${w.y} `,t+=" Z";else if(s==="circle1"){let p=g*1.36,$=u(a,E,0,p/e),P=u(a,M,0,-(p/e)),x=u(i,k,0,p/e),S=u(i,F,0,-(p/e));t=`M ${$.x},${$.y} A ${a},${a} 0 ${l} 1 ${P.x},${P.y}`,t+=` A 1,1 0 0 1 ${S.x},${S.y} `,t+=` A ${i},${i} 0 ${l} 0 ${x.x},${x.y}`,t+=` A 1,1 0 0 1 ${$.x},${$.y} `,t+=" Z"}else if(s==="arrow"){let p=u(c,M,0,24/e/2),$=u(c,E,0,24/e/2);t=`M ${w.x},${w.y} A ${a},${a} 0 ${l} 1 ${R.x},${R.y}`,t+=`L ${p.x} ${p.y}`,t+=`L ${f.x} ${f.y}`,t+=`A ${i},${i} 0 ${l} 0 ${y.x}, ${y.y}`,t+=`L ${$.x} ${$.y}  `,t+="Z"}else if(s==="backslash"||s==="slash"){let p=u(a,E,0,s==="backslash"?0:24/e/2),$=u(a,M,0,s==="backslash"?0:24/e/2),P=u(i,k,0,s==="backslash"?24/e/2:0),x=u(i,F,0,s==="backslash"?24/e/2:0);t=`M ${p.x},${p.y} A ${a},${a} 0 ${l} 1 ${$.x},${$.y}`,t+=`L ${x.x} ${x.y}`,t+=`A ${i},${i} 0 ${l} 0 ${P.x}, ${P.y}`,t+="Z"}else s==="nr"?(t=`M ${w.x},${w.y} A ${a},${a} 0 ${l} 1 ${R.x},${R.y}`,t+=`L ${f.x} ${f.y}`,t+=`A ${i},${i} 0 ${l} 0 ${y.x}, ${y.y}`,t+="Z"):(t=`M ${w.x},${w.y} A ${a},${a} 0 ${l} 1 ${R.x},${R.y}`,t+=`L ${f.x} ${f.y}`,t+=`A ${i},${i} 0 ${l} 0 ${y.x}, ${y.y}`,t+="Z");return{dShape:t}}calculateTextArcParameters(){let{arcAngle:r,realRadius:n,gap:h,flip:o}=this.getAttributes(),e=n,s,d,g,c,l,t,b,A=h*.5;b=o?0:1,l=r<=180?0:1;let C=50+e*Math.cos((-90+A)*(Math.PI/180)),a=50+e*Math.sin((-90+A)*(Math.PI/180)),i=50+e*Math.cos((r-90-A)*Math.PI/180),v=50+e*Math.sin((r-90-A)*Math.PI/180);return o?(s=i,d=v,g=C,c=a):(s=C,d=a,g=i,c=v),t=`M ${s},${d} A ${e},${e} 0 ${l} ${b} ${g},${c}`,{dPath:t}}};function B(I){let r=I.match(/calc\(\s*([\d.]+)deg\s*\/\s*\(\s*(\d+)\s*-\s*(\d+)\s*\)\s*\)/);if(r){let n=parseFloat(r[1]),h=parseInt(r[2])-parseInt(r[3]);if(!isNaN(n)&&!isNaN(h)&&h!==0)return n/h}}var N={};N={resize:I=>{let r=document.querySelector(I);if(!r){console.error(`Not found: ${I}`);return}new ResizeObserver(h=>{for(let o of h){let{width:e}=o.contentRect,s=r.querySelectorAll(".gravity-spot");s?s.forEach(d=>{let g=getComputedStyle(d).getPropertyValue("--o-force"),c=e/500;d.style.setProperty("--o-force-ratio",`${c}`)}):console.error("No gravity-spot found")}}).observe(r)}};customElements.get("o-progress")||customElements.define("o-progress",H);customElements.get("o-arc")||customElements.define("o-arc",q);window.Orbit=N;})();
